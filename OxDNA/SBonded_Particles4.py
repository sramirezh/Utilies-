"""

Before running this script, Split.sh has to be executed in order to split both the trajectory and the 
bond list file from oxDNA

This script is intended first to read the bond output from oxDNA "BoxDNA" and compare it with the imposed
bonds by the harmonic traps in the file "Binput" generated by the Generating_Network.py

Inputs

-Splited bond_list
-Topology File.
-Times.dat

Becareful with the Step variable. it has to be put by hand

Nomenclature:

Group is the entire structure, either bridge or Tetramer, when we refer to a group, it does include all the 
internal particles, but is coarse grained, as a patchy particle approximation.

Revisions:

V2 includes the new way of counting, including non-integer bonding.
Main modifications were made in:

OptimizeBondList, now it does not deletes double bonds.
getBonded() Still avoids T-T interaction and a counter was added to take into account several bonds at same point.
getBSAToArm() the bsa now is an array of doubles (Previously integers) and the new way of counting is implemented.


V3 Defines a way of counting the total switching.
-removed the dependency in the configuration file which now is not necessary because of the new way of counting.
-before we need to run Split3.sh just splits the bonded_list

V4
-Includes a generalization for more than 2 bridges interacting at the same arm, partially.
Only going to focus in the first two bridges.
-Im assuming that the three bridge interaction is very rare so I am not following this entire process..
I just focus on the initial two bridges.
-If after the 3 bridges interaction ends, then a new evolution is created,
"""
import time
import numpy as np
import cPickle as pickle
start_time = time.time()

"""
*******************************************************************************
Function Definition
*******************************************************************************
"""

def FindDuplicates(Array):
    """
    Return the duplicate values of an Array of integer
    """
    Histo=np.zeros(int(np.max(Array))+1)
    for i in xrange(np.size(Array)):
        Histo[int(Array[i])]+=1
    duplicates=np.where(Histo>1)[0]
    return duplicates



def OptimizeBondList(BoxDNA):
    """
    Reads the pair bond list created based on the HB_list from oxDNA, which writes a bond
    if the interaction between the particles is smaller than HB_Cutoff=0.1.
    If there is a double bond, deletes the one which is weaker i.e longer distance between particles.
    
    NewBonds    =   Output containes the sorted Bond list, after deleting the double bonds. 
                    Also showing twice the bonds, the first half is redundant with the second.
                    
    V2= does not delete
    """
                    
    #Creating an array with all the bonds in the first row there are the particles organized increasing their identification number
    A=np.copy(BoxDNA)
    A=np.append(A,BoxDNA[:,[1,0]],axis=0)
    NewBonds=A[A[:,0].argsort()]   
    
    return NewBonds
    
def BuildStatic(Tetramers):
    """
    
    Outputs:
    
    BondList : is the BSA which is an array where in every entrance has the arm and on every arm,
    has the bridges attached and them with the number of bonds in the switching area.
    
    BPA=contains the number of bridges, per arm per tetramer.
    
    
    Output structure
    
    BondList[Tetramer][ARM#][Bridge ID][Number of Bonds]
    
    BPA [Tetramer][ARM#][bridgesinTheArm]
    """
    BondList=[]
    BPA=[]
    for i in xrange(Nt):
        BondListPerArm=[]
        BPA.append(Tetramers[i].getBonded()[3])
        for j in xrange(4): #Counts over the arms
            BondListPerArm.append(Tetramers[i].getBSAToArm(j))
        BondList.append(BondListPerArm)
    return BondList,BPA
    
def build_data():

    
    #Reading the energies to get the total number of input files
    Times=np.loadtxt("Times.dat",dtype=int)
    x=np.size(Times)
    
    
    
    dbsa=[]
    dbpa=[]
    for k in xrange(x): #Runs over the sampled times.
    
        print("Reading configuration %d of %d" %(k,x-1))
        #Reading the Results 
        name_bl=str(int(Times[k]))+".bl"
          
        
        #Opening the configuration and bl files
        #conf=np.loadtxt(name_conf) #Position of all the particles. 
        BoxDNA=np.loadtxt(name_bl,dtype=int) #Bonded Particles from oxDNA
        
        
        Blist=OptimizeBondList(BoxDNA)
        
    
        Blistt=Blist[0:np.min(np.where(Blist[:,0]>Nt*NPt)[0]),:] #List containing in the first row the particle in a tetramer and then the bonded particle
        Blistb=Blist[np.min(np.where(Blist[:,0]>Nt*NPt)[0])::,:]

        
        """
        *******************************************************************************
        Initializing the System
        *******************************************************************************
        """
        Tetramers=[]
        for i in xrange(Nt):
            MakeTetramers(i,Blistt,Tetramers)
        Bridges=[] 
        for i in xrange(Nb):
            MakeBridges(i,Blistb,Bridges)
    
    
        """
        *******************************************************************************
        Building the BSA(bonding switching area) Dynamical vector
        *******************************************************************************
        """
        
        bsa,bpa=BuildStatic(Tetramers)
        
        bpa=np.array(bpa) #This is the key to analyze the dynamics.
        
        dbsa.append(bsa)
        dbpa.append(bpa)
    return x,dbsa,dbpa
    

def ArrayBinA(A,B):
    """
    Inputs Arrays A and B, unidimensional arrays.
    output: True if all elements of B are in A, otherwise False
    """
    output=True
    cont=0
    for element in B:
        if element in A: 
            cont+=1
    if cont!=np.size(B):
        output=False
    return output
    
        
    

"""
*******************************************************************************
CLASS DEFINITION
*******************************************************************************
"""

class Constituents(object):
    
    def MakeArms(self,NumberOfArms):
        """
        Builds the arms assigning the number to every particle on it
        """
        x=np.split(self.components,NumberOfArms)
        return x  
        
    def getElements(self):
        """
        Return the elements that form the Tetramer or Bridge
        """
        return self.components
        
    def getId(self):
        """
        Gives the identity of the Group in the absolute reference, i.e counting
        from the first tetramer till the final and then continue with the first bridge
        """
        return self.id
        
    def getArm(self,i):
        """
        Give the elements of the desired arm
        """
        return self.MakeArms(self.arms)[i]
    
    

    
    
        
class Tetramer(Constituents): 
     
    def __init__(self, Number,Indexes,Blistt):
        self.components=Indexes
        self.id = Number 
        self.arms=4
        self.Blist=Blistt
        
    def getBonded(self):
        """
        Returns 
        
        BIdentity : is an array of 4 arrays, one for each arm. Each containing the identity of the 
        bridge(s) that is bonded to the arm.
        
        Bonded: is an array of 4 arrays, one for each arm. Each containing the pairs of bonded particles,
        in the first column the tetramers particle number and in the second the one from the bridge, in 
        the third column the tetramer particle in the frame of the arm (i.e 2 is the first patchy particle)
        
        BIdetail : same as BIdentity but with the bridge index at every position of the tetrameric
        arm.
        
        BPA=Give the numbers of bridges bonded per arm, per tetramer
        """
        Bonded=[] #Contain a cluster per arm, every cluster with the particle in the tetramer and the bonded to it, the last column is index in the tetrameric arm frame
        BIdentity=[] #Only contains the Index of the bridges bonded
        BIdetail=[] #Contains the index of the bridges bonded to every point
        BPA=[]
        Blistt=self.Blist
        for i in xrange(self.arms):
            #Initializing the same arrays as always but per Arm
            BondedPerArm=[]
            BIdentityPerArm=[]
            Constituents=self.getArm(i)
            for j in xrange(np.size(Constituents)):
                if j>0 and j%2==0: #Only takes into account patchy particles
                    index=np.where(Blistt[:,0]==Constituents[j])[0]
                   
                    for k in xrange(np.size(index)): #To include the other bonds for the new way of counting
                        if np.size(index)==0 or Blistt[index[k],1]<Nt*NPt:continue #Second condition to avoid counting Tetra-Tetra bonding
                        else:
#                            if np.size(index)>1:print(k,index[k],np.size(index),self.getId(),Blistt[index[k],1])
                            BondedPerArm.append([Blistt[index[k],0],Blistt[index[k],1],j])
                            BIdentityPerArm.append((Blistt[index[k],1]-Nt*NPt)/NPb+Nt) 
                        
                        #Aca tambien se puede ver con % SI ES EN BWS
            Bonded.append(np.array(BondedPerArm))
            BIdentity.append(np.unique(BIdentityPerArm)) #Unique to get only one counter 
            BIdetail.append(BIdentityPerArm)
            BPA.append(np.size(BIdentity[-1]))
        return BIdentity,Bonded,BIdetail,BPA
        
    def getBondedToArm(self,i):
        """
        Returns an array containing the identity (in absouluite numeration, i.e counting from the tetramers, then bridges)
        of the bridges that are bound to the specific arm.
        """
        return self.getBonded()[0][i] #getting BIdentity
    
    def getBSAToArm(self,i):
        """
        Outputs:
        
        bsa : an array containing in the first row the Number of the bridge(even if they are not bonded to
        the bonding switching area) and then the Number of bonds in the Switching Area for a given arm i of a tetramer. 

        """
        BSAindexes=[10,12,14,16] #Indexes of the Bonding switching area in the arm frame
        BridgesId=np.array(self.getBonded()[0][i])
        Bridges=np.array(self.getBonded()[1][i])
        Identities=np.array(self.getBonded()[2][i])
        
        
        
        OutputSize=np.size(BridgesId)#Number of bridges attached to the arm
        if OutputSize==0:
            bsa=[]
        else:
            bsa=np.zeros((OutputSize,2))
            bsa[:,0]=BridgesId
            for index in BSAindexes:       
                match=np.where(Bridges[:,2]==index)[0]
                if np.size(match)==0:continue #If there is no particle bonded to that position in the BSA
                
                
                #Part of the implementation of the way of counting
                bsaBridge=Identities[np.where(Bridges[:,2]==index)] #Bridge in the bsa index,
                NbAtSamePoint=np.size(bsaBridge) #Number of bridges Attached to the same point
                
                increase=1./NbAtSamePoint #In general this is 0.5 I dont think there would be more than 2 bridges attached to the same point            
                for k in xrange(NbAtSamePoint):
                    for j in xrange(OutputSize):
                        if bsaBridge[k]==bsa[j,0]:
                            bsa[j,1]+=increase
        return bsa
            
class Bridge(Constituents):
    
    def __init__(self, Number,Indexes,Blistb):
        self.components=Indexes
        self.id = Number
        self.arms=2
        self.Blist=Blistb #Bonding list to bridges

    


def MakeTetramers(i,Blistt,Tetramers):
    Tetramers.append(Tetramer(i,np.arange(i*NPt,(i+1)*NPt,1),Blistt))
    return Tetramers
    

def MakeBridges(i,Blistb,Bridges):
    Bridges.append(Bridge(i+Nt,np.arange(i*NPb,(i+1)*NPb,1)+Nt*NPt,Blistb))
    return Bridges
    
"""
*******************************************************************************
PROGRAM STARTS HERE
*******************************************************************************
"""

"""
input parameters
"""
print "Be careful with the input parameters!!!!!!!!!!!!!!!!!!!!!!!!"
dt = 0.002 #Defined in the input file.

"""
*******************************************************************************
Some configurational Parameters.
*******************************************************************************
"""
NPtarm=12 #Number of Nucleotides in a tetramer arm
NPbarm=8 #Number of Nucleotides in a Bridge arm

TPtarm=NPtarm*2+1 #Total N of Particles in Tetramer arm
TPbarm=NPbarm*2+1 #Total N of Particles in Bridge arm.

NPt=TPtarm*4  #Total Number of Particles in a Tetramer
NPb=TPbarm*2  #Total Number of Particles in Bridge

"""
*******************************************************************************
Reading the initial files
*******************************************************************************
"""
#Reading the Topology File
inp=open("topology.dat",'r')
line=inp.readline()
NtPart,Nt,Nb=np.array(line.split(),dtype=int) #Total number of particles, #Tetramers,#Bridges
inp.close()
#

#Getting the simulation times
Times=np.loadtxt("Times.dat")
Step=0.002
Deltat=(Times[1]-Times[0])*Step

print("The Time Step is:%f , the bond_list Sampling time is:%d , so the Delta t between Samplings is:%f Deltat"%(Step,Times[1]-Times[0],Deltat))



"""
*******************************************************************************
Building arrays for Analysis.

Reads all the evolution of the system and gets the necessary data for the 
analysis. After, this has run once it can be commented and just run the program
with the loaded arrays on the temporary memory in Spyder for example.

*******************************************************************************
"""

x,dbsa,dbpa=build_data() #Building the required arrays from data.

"""
SAVING THE LISTS
"""
afile = open(r'x.pkl', 'wb')
pickle.dump(x, afile)
afile.close()


afile = open(r'dbsa.pkl', 'wb')
pickle.dump(dbsa, afile)
afile.close()


afile = open(r'dbpa.pkl', 'wb')
pickle.dump(dbpa, afile)
afile.close()

"""
LOAD LIST
"""

##reload object from file
#file2 = open(r'x.pkl', 'rb')
#x = pickle.load(file2)
#file2.close()
#
#
#file2 = open(r'dbsa.pkl', 'rb')
#dbsa = pickle.load(file2)
#file2.close()
#
#
#file2 = open(r'dbpa.pkl', 'rb')
#dbpa = pickle.load(file2)
#file2.close()




"""
*******************************************************************************
Creating some auxiliary structures
*******************************************************************************
"""
InteractionMap=np.zeros((Nt*4,x))# Contains a row for every tetrameric arm, and a column for every time
for i in xrange(x):
    
    #Identifiying where is there an interaction of two bridges with a Tetrametic Arm
    indexes=np.where(dbpa[i]>=2)
    for j in xrange(np.size(indexes[0])):
        InteractionMap[indexes[0][j]*4+indexes[1][j]][i]=1 #Sets a 1 if there are two bridges interacting in one arm

#Building a matrix which contains in the first row the Tetramer and then the arm, just to help identify
A=np.zeros((Nt*4,2),dtype=int)
cont=0
for i in xrange(Nt):
    for j in xrange(4):
        A[cont,0]=i
        A[cont,1]=j
        cont+=1

SumInteraction=np.sum(InteractionMap, axis=1)


FocusIndex=np.where(SumInteraction>1) #Where there is  Dynamical interaction



"""
*******************************************************************************
Building the Evolution Array

Evolutions has all the events where there is interaction between bridges, for
the i-th element it has:

[[Tetramer,Arm,Bridge1,Bridge2],[[BSA1(t)],[BSA2(t)],[times]]]
*******************************************************************************
"""
#Initializing everything

Evolutions=[]
cont=-1
OldBridges=np.zeros(2)
ABridges=np.zeros(2) 
for index in FocusIndex[0]:
    cont2=0
    for t in xrange(x):
        
        #This condition is to restart the counter when there is no interaction of bridges, or when the original bridges change, starting a new evolution.
        #Also starts a counter when from 3 interacting bridges evolve into 2, this generates a loose in the sampled events but is for simplicity.
        if InteractionMap[index,t]==0 or ArrayBinA(ABridges,OldBridges)==False or np.size(OldBridges)>np.size(ABridges):
                cont2=0 #Restart the counter while in temporal frame when they dont interact
        if InteractionMap[index,t]==1:
            TetramerId=A[index][0]
            ArmId=A[index][1]
            
            #Generalization for more than 2 bridges interacting in the same arm
            bsa=dbsa[t][TetramerId][ArmId] #Bonds in Switching area for the bridges in the arm
            NbridgesInArm=dbpa[t][TetramerId][ArmId] #Number of bridges in the arm
            ABridges=np.zeros(NbridgesInArm) #Array contain the bridge number
            Nbsa=np.zeros(NbridgesInArm) #Contains the bonds in sa.
            
            for b in xrange(NbridgesInArm): #Runs aver all the bridges
                ABridges[b]=bsa[b][0]
                Nbsa[b]=bsa[b][1]
                
                """At the beginning only two bridges are interacting, we are going to focus on then"""
            if cont2==0: #To state that during the evolutions the bridges also need to be the same
                OldBridges[0]=bsa[0][0]
                OldBridges[1]=bsa[1][0]
                Bsa1=Nbsa[np.where(ABridges==OldBridges[0])]
                Bsa2=Nbsa[np.where(ABridges==OldBridges[1])]
                Evolutions.append([[TetramerId, ArmId,OldBridges[0], OldBridges[1]],[[Bsa1],[Bsa2],[t]]])
                cont+=1
                
            #After here it is not yet generalized   
           
            if cont2>0 and InteractionMap[index,t-1]==1 and ArrayBinA(ABridges,OldBridges): #Only append evolution
                Bsa1=Nbsa[np.where(ABridges==OldBridges[0])]
                Bsa2=Nbsa[np.where(ABridges==OldBridges[1])]
                Evolutions[cont][1][0].append(Bsa1)
                Evolutions[cont][1][1].append(Bsa2)
                Evolutions[cont][1][2].append(t)
                
            cont2+=1

"""
*******************************************************************************
Finding the Switchings
*******************************************************************************
"""
i=0
Swt=[] #Initializing the arrays.
FullSwt=[]
for element in Evolutions:
    n=np.size(element[1])    
    if np.max(element[1][0])==4 and np.max(element[1][1])==4:
        print("We got some switchings in evolutions[%d], starting at Time %d,lasting %d sampled steps, with elements: , "%(i,element[1][2][0],np.size(element[1][2])),element[0])
        """Getting the switching times"""
        bsa2=np.array(element[1][0])
        bsa3=np.array(element[1][1])
        a=np.where(bsa2==4)[0]          
        b=np.where(bsa3==4)[0]
        A=np.zeros((np.size(a)+np.size(b),2),dtype=int)
        A[0:np.size(a),0]=a
        A[0:np.size(a),1]=1 #This value when strand 2 is bonded
        A[np.size(a)::,0]=b
        A[np.size(a)::,1]=2 #This value when strand 3 is bonded
        B=A[A[:,0].argsort()]  #to sort A with respect to the first column
        """The switching occurs between j when there were 4 bonds in one strand and j+1 when there are 4 bonds 
        in the other
        """
        Swc=0; #Counts the number of switchings
        for j in xrange(np.size(a)+np.size(b)-1):
            if B[j+1,1]-B[j,1]!=0:
                Swc+=1
                Swt.append(B[j+1,0]-B[j,0]) #switching time in MD steps
                
        """Finding the full switchings"""
        if np.max(element[1][2])<x-1 and np.min(element[1][2])>0 and B[0,1]!=B[-1,1]:
            print("EUREKA!!!! This Interaction generates a complete switching")
            FullSwt.append(np.max(element[1][2])-np.min(element[1][2]))
    i+=1
Swt=np.array(Swt)
        
##Deleting Switching times equal to zero
deleterows=np.where(Swt==0)[0]
Swt=np.delete(Swt,deleterows,axis=0)
Swt_t=Swt*Deltat #In reduced time 
        
    

Swt_av=np.average(Swt)
Swt_av_t=np.average(Swt_t)
error=np.sqrt(np.var(Swt)/np.size(Swt))
error_t=np.sqrt(np.var(Swt_t)/np.size(Swt))
print("Measured %d Switchings, The Average switching time is [Reduced time(MD steps)]=%f(%f) with Error=%f(%f)" %(np.size(Swt),Swt_av_t,Swt_av,error_t,error))
np.savetxt("Swtimes_reduced4.dat", Swt_t)

if np.size(FullSwt)!=0:
    FullSwt=np.array(FullSwt)
    FullSwt_t=FullSwt*Deltat #In reduced time 
    FullSwt_av=np.average(FullSwt)
    FullSwt_av_t=np.average(FullSwt_t)
    Full_error=np.sqrt(np.var(FullSwt)/np.size(FullSwt))
    Full_error_t=np.sqrt(np.var(FullSwt_t)/np.size(FullSwt))
    print("Measured %d Total Switchings, The Average switching time is [Reduced time(MD steps)]=%f(%f) with Error=%f(%f)" %(np.size(FullSwt),FullSwt_av_t,FullSwt_av,Full_error_t,Full_error))
    np.savetxt("Total_Swtimes_reduced4.dat", FullSwt_t)

elapsed_time = (time.time() - start_time)/60.0

print("Elapsed Time %f minutes" %elapsed_time)
#np.savetxt("Swtimes_reduced.dat", Swt_t)
#"""
#*******************************************************************************
#Making the Histogram
#*******************************************************************************
#"""
#Histo=np.zeros((np.max(Swt)+1,2))
#Histo[:,0]=np.linspace(np.min(Swt),np.max(Swt),np.max(Swt)+1)
#for i in xrange(np.size(Swt)):
#    Histo[Swt[i],1]+=1
#Histo[0,1]=0 #Deleted the counts here because they are anomalies where the bsa is double bonded. 
#
##Remove the points with zero counts, for the sake of the plot and the conf which have "triple bond"
#deleterows=np.where(Histo[:,1]==0)[0]
#Histo=np.delete(Histo,deleterows,axis=0)
#
##Normalize the Histogram
#Histo[:,0]=Deltat*Histo[:,0] #To get the real time 
#Area=np.trapz(Histo[:,1],Histo[:,0])
#Histo[:,1]=Histo[:,1]/Area
#
#plt.plot(Histo[:,0],Histo[:,1])  
#plt.savefig('Histo2.png')
#np.savetxt("Histogram2",Histo)

"""
*******************************************************************************
Building the Visibility file

this can be used in cogli with the flag -i Visibility

We just take the output on the command line, for example:

('we got some switchings in evolutions[147], starting at Time 115 with elements: ', [31, 2, 124.0, 193.0])

and we fill the parameters in the code consequently
Tet=31
Arm=2
Bris=dbsa[115][Tet][Tarm][:,0]-Nt
*******************************************************************************
"""    


#Ntet=4*(TPtarm*2-1) #Particles in a tetramer including bonds
#NBrid=2*(TPbarm*2-1) #Particles in a Bridge including bonds
#Tet=31 #Desired tetramer
#Tarm=0 #Desired Arm
#Bris=dbsa[274][Tet][Tarm][:,0]-Nt
#TArm=np.arange((Tet)*Ntet,(Tet)*Ntet+Ntet)
#initial=Ntet*Nt+(Bris[0])*NBrid
#B1=np.arange(initial,initial+NBrid)
#initial=Ntet*Nt+(Bris[1])*NBrid
#B2=np.arange(initial,initial+NBrid)
#Delete=np.arange(NtPart*2-1)
#Delete=np.delete(Delete,B2)
#Delete=np.delete(Delete,B1)
#Delete=np.delete(Delete,TArm)
#np.savetxt("Visibility",Delete, fmt="%d")
    
